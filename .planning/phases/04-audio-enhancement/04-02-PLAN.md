---
phase: 04-audio-enhancement
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/hooks/useAudioControls.ts
  - src/components/AudioControls.tsx
autonomous: true

must_haves:
  truths:
    - "Volume changes use Web Audio API shared GainNode for smooth transitions (no clicking)"
    - "Playback rate changes apply to audio elements in real-time"
    - "Mute toggle silences audio via volume smoothing, not direct muting"
    - "applyGlobalVolume function available for connecting any audio element to shared audio context"
  artifacts:
    - path: "src/hooks/useAudioControls.ts"
      provides: "Web Audio API integration with shared AudioContext/GainNode"
      exports: ["useAudioControls"]
    - path: "src/components/AudioControls.tsx"
      provides: "UI component for audio controls (volume, speed, mute, enable)"
      exports: ["AudioControls", "applyGlobalVolume"]
  key_links:
    - from: "src/hooks/useAudioControls.ts"
      to: "src/store/audioStore.ts"
      via: "useAudioStore hook import"
      pattern: "from.*audioStore"
    - from: "src/components/AudioControls.tsx"
      to: "src/hooks/useAudioControls.ts"
      via: "useAudioControls hook import"
      pattern: "from.*useAudioControls"
    - from: "src/components/AudioControls.tsx"
      to: "src/store/audioStore.ts"
      via: "useAudioStore hook import"
      pattern: "from.*audioStore"
    - from: "src/hooks/useTTS.ts"
      to: "src/components/AudioControls.tsx"
      via: "applyGlobalVolume function import for audio element connection"
      pattern: "from.*AudioControls"
---

<objective>
Create audio controls implementation with Web Audio API GainNode for smooth volume transitions, and UI component for user to adjust volume, playback speed, and mute toggles.

Purpose: Provide user-facing audio controls that prevent audio clicking and enable real-time adjustment of audio playback.

Output: useAudioControls hook with GainNode smoothing, AudioControls component with volume/speed/mute/enable UI.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-audio-enhancement/04-RESEARCH.md
@.planning/phases/04-audio-enhancement/04-01-PLAN.md

# Existing codebase
@src/store/audioStore.ts
@src/hooks/useTTS.ts
@src/api/tts.ts

# Prior phase summaries (for patterns)
@.planning/phases/04-audio-enhancement/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useAudioControls hook with shared AudioContext and GainNode</name>
  <files>src/hooks/useAudioControls.ts</files>
  <action>
Create `src/hooks/useAudioControls.ts` with the following:

1. Import useRef, useEffect, useCallback from react
2. Import useAudioStore from store/audioStore
3. Define hook signature: useAudioControls()
4. Create global audioContextRef and gainNodeRef as module-level refs (outside hook) for single shared instance
5. Initialize AudioContext on first call:
   - Create AudioContextClass = window.AudioContext || window.webkitAudioContext
   - Lazy initialize on first use (not on mount)
   - Resume if suspended (browser autoplay policy)
6. Create single shared GainNode in audioContext
7. Connect GainNode to destination (no source - acts as global volume control)
8. Implement setVolume function using GainNode.gain.setTargetAtTime:
   - Parameters: target value, audioContext.currentTime, timeConstant (0.02 for 20ms smoothing)
   - This prevents audio clicking
9. Implement applyVolumeToAudio(audioElement: HTMLAudioElement) function:
   - Takes HTMLAudioElement as parameter
   - Creates MediaElementSource from audioElement
   - Connects: audioElement â†’ sharedGainNode â†’ destination
   - Applies current volume from gainNode
10. Return { setVolume, applyVolumeToAudio, initializeAudio }

CRITICAL: Use GainNode.setTargetAtTime for volume changes to prevent clicking. Do NOT use direct audio.volume assignment.

DO NOT:
- Initialize AudioContext on mount (violates autoplay policy)
- Create persistent audio element (accepts audio elements as parameters)
- Create multiple GainNodes (use single shared instance)

Reference Pattern 2 from 04-RESEARCH.md for Web Audio API implementation details.
  </action>
  <verify>
```bash
npm run build
```
Build succeeds without TypeScript errors.
  </verify>
  <done>
useAudioControls hook created with shared AudioContext, single GainNode, setVolume/applyVolumeToAudio/initializeAudio functions returned.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AudioControls component with volume/speed/mute UI</name>
  <files>src/components/AudioControls.tsx</files>
  <action>
Create `src/components/AudioControls.tsx` with the following:

1. Import useAudioStore from store/audioStore
2. Import useAudioControls from hooks/useAudioControls
3. Get state from useAudioStore: volume, playbackRate, isMuted, isEnabled, setVolume, setPlaybackRate, toggleMute, toggleEnabled
4. Get { setVolume as smoothVolume, initializeAudio } from useAudioControls()
5. Implement useEffect to apply volume changes:
   - When volume or isMuted changes, call smoothVolume with effective volume (0 if muted, else volume)
   - When isEnabled changes, handle TTS enable/disable in streaming components
6. Add useEffect for AudioContext initialization:
   - Call initializeAudio() on first user interaction with any control (volume, speed, mute, enable)
   - This ensures AudioContext resumes from suspended state
7. Render UI with Tailwind CSS:
   - Container div with flex layout, gap-4, p-4, bg-gray-100 rounded-lg
   - Volume slider: input type="range" min="0" max="2" step="0.01", displays percentage
   - Playback speed slider: input type="range" min="0.5" max="2.5" step="0.1", displays "x" multiplier
   - Mute toggle button: shows ðŸ”Š/ðŸ”‡ emoji, styled with conditional bg
   - Enable toggle button: shows "Audio On/Off", controls global TTS
8. Add appropriate aria-labels for accessibility
9. Export function to apply global volume to any audio element:
   - Export applyGlobalVolume(audioElement: HTMLAudioElement) function
   - Calls applyVolumeToAudio from useAudioControls

DO NOT:
- Create persistent audio element (useAudioControls uses shared AudioContext, accepts audio elements as parameters)
- Connect to streaming TTS directly (integration is in next plan)
- Persist settings to localStorage (keep runtime-only)
- Add advanced audio effects (reverb, equalizer, etc.)

Reference "Complete Audio Control Component" example from 04-RESEARCH.md for implementation patterns.
  </action>
  <verify>
```bash
npm run build
```
Build succeeds without TypeScript errors.
  </verify>
  <done>
AudioControls component created with volume slider (0-200%), playback speed slider (0.5x-2.5x), mute toggle, enable toggle, exported applyGlobalVolume function, useAudioControls integration for smooth volume via shared GainNode.
  </done>
</task>

</tasks>

<verification>
- useAudioControls compiles with GainNode smoothing implementation
- AudioControls component renders with all controls
- Volume changes use setTargetAtTime (not direct assignment)
- Hidden audio element exists for audio graph connection
- Accessibility labels present on all interactive elements
</verification>

<success_criteria>
Build succeeds, AudioControls component renders all controls (volume, speed, mute, enable), useAudioControls provides smooth volume transitions via GainNode.
</success_criteria>

<output>
After completion, create `.planning/phases/04-audio-enhancement/04-02-SUMMARY.md`
</output>
