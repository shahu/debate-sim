---
phase: 03-streaming
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified: [src/components/StreamingTranscriptEntry.tsx, src/components/TranscriptPanel.tsx, src/store/debateStore.ts]
autonomous: true

must_haves:
  truths:
    - "User sees text appear incrementally as AI generates content"
    - "Streaming text display updates smoothly without jank"
    - "Completed entries transition to final state seamlessly"
  artifacts:
    - path: "src/components/StreamingTranscriptEntry.tsx"
      provides: "Real-time streaming text display component"
      exports: ["StreamingTranscriptEntry"]
      min_lines: 60
    - path: "src/store/debateStore.ts"
      provides: "Streaming state management"
      contains: "streamingEntryId"
  key_links:
    - from: "src/components/StreamingTranscriptEntry.tsx"
      to: "src/hooks/useStreamingText.ts"
      via: "hook consumption for display"
      pattern: "useStreamingText\\("
    - from: "src/store/debateStore.ts"
      to: "streaming entry tracking"
      via: "state actions"
      pattern: "setStreamingEntry|finalizeStreamingEntry"
---

<objective>
Wire streaming AI content into the debate UI with smooth real-time display.

Purpose: Make streaming visible to users through incremental text display in transcript
Output: Streaming-capable transcript components integrated with debate state
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-streaming/03-RESEARCH.md

# Dependencies
@.planning/phases/03-streaming/03-01-SUMMARY.md

# Files to modify
@src/components/TranscriptPanel.tsx
@src/store/debateStore.ts
@src/types/debate.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create streaming transcript entry component</name>
  <files>src/components/StreamingTranscriptEntry.tsx</files>
  <action>
Create `StreamingTranscriptEntry` component for displaying real-time streaming content:

1. Accept props: `{ speaker: SpeakerRole, streamGenerator: AsyncIterable<string> | null, onComplete: (finalText: string) => void }`
2. Use `useStreamingText` hook from 03-01 to consume stream
3. Display using same visual style as existing `SpeakerCard` component:
   - Same role-based colors from speaker-colors.css
   - Add subtle "typing indicator" animation while streaming (pulse opacity on border)
4. When stream completes (isStreaming becomes false):
   - Call `onComplete(displayText)` with final text
   - Remove typing indicator animation
5. Handle error state with error message display
6. Use `fadeIn` animation from animations.css on mount

Visual differences from static SpeakerCard:
- Pulsing border while streaming (use `pulse` animation from animations.css)
- Slightly dimmer background to indicate "in progress" state
- Remove pulse and restore normal styling on completion

Why separate component: Streaming entries have different lifecycle (active accumulation) vs completed entries (static display).
  </action>
  <verify>
1. Check component exports: `grep "export.*StreamingTranscriptEntry" src/components/StreamingTranscriptEntry.tsx`
2. Check hook usage: `grep "useStreamingText" src/components/StreamingTranscriptEntry.tsx`
3. Check onComplete callback: `grep "onComplete.*finalText" src/components/StreamingTranscriptEntry.tsx`
4. Verify TypeScript compiles: `npm run build`
  </verify>
  <done>
- StreamingTranscriptEntry component exists
- Uses useStreamingText hook for streaming display
- Matches SpeakerCard visual style with streaming indicators
- Calls onComplete when stream finishes
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add streaming state to debate store</name>
  <files>src/store/debateStore.ts</files>
  <action>
Extend DebateState interface and store to support streaming entries:

1. Add to DebateState interface:
   ```typescript
   streamingEntry: {
     id: string;
     speaker: SpeakerRole;
     streamGenerator: AsyncIterable<string> | null;
   } | null;
   ```

2. Add actions to DebateState interface:
   ```typescript
   startStreamingEntry: (speaker: SpeakerRole, streamGenerator: AsyncIterable<string>) => void;
   finalizeStreamingEntry: (finalText: string, wordCount: number) => void;
   cancelStreamingEntry: () => void;
   ```

3. Implement actions in store:
   - `startStreamingEntry`: Sets streamingEntry with new id, speaker, and generator
   - `finalizeStreamingEntry`: Converts streaming entry to permanent transcript entry, clears streamingEntry state
   - `cancelStreamingEntry`: Clears streamingEntry without adding to transcript (for error cases)

4. Update `resetDebate` action to also clear `streamingEntry: null`

Why separate streaming state: Allows UI to distinguish between "content being generated" vs "completed content" for different rendering.
  </action>
  <verify>
1. Check interface update: `grep "streamingEntry" src/store/debateStore.ts | head -5`
2. Check action implementations: `grep "startStreamingEntry\|finalizeStreamingEntry" src/store/debateStore.ts`
3. Verify TypeScript compiles: `npm run build`
4. Check zustand store creation: `npm run build 2>&1 | grep -i error || echo "No errors"`
  </verify>
  <done>
- streamingEntry field added to DebateState
- startStreamingEntry, finalizeStreamingEntry, cancelStreamingEntry actions implemented
- resetDebate clears streaming state
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire streaming into TranscriptPanel</name>
  <files>src/components/TranscriptPanel.tsx</files>
  <action>
Update TranscriptPanel to display both completed entries and active streaming entry:

1. Import `StreamingTranscriptEntry` component
2. Import `useDebateStore` and read both `transcript` and `streamingEntry` from state
3. Render logic:
   ```tsx
   {transcript.map(entry => <SpeakerCard key={entry.id} {...entry} />)}
   {streamingEntry && (
     <StreamingTranscriptEntry
       speaker={streamingEntry.speaker}
       streamGenerator={streamingEntry.streamGenerator}
       onComplete={(finalText) => {
         const wordCount = finalText.split(/\s+/).length;
         finalizeStreamingEntry(finalText, wordCount);
       }}
     />
   )}
   ```
4. Auto-scroll should trigger on both new transcript entries AND when streamingEntry appears
5. Keep existing "scroll to bottom" button behavior

Integration points:
- Streaming entry renders AFTER all completed entries
- onComplete callback saves to transcript via store action
- Auto-scroll fires when streamingEntry state changes (useEffect dependency)

Why this architecture: Single source of truth in store, clear separation between mutable (streaming) and immutable (completed) entries.
  </action>
  <verify>
1. Check StreamingTranscriptEntry import: `grep "import.*StreamingTranscriptEntry" src/components/TranscriptPanel.tsx`
2. Check store usage: `grep "streamingEntry.*useDebateStore" src/components/TranscriptPanel.tsx`
3. Check onComplete wiring: `grep "finalizeStreamingEntry" src/components/TranscriptPanel.tsx`
4. Verify TypeScript compiles: `npm run build`
5. Check component renders: `npm run dev` and verify no console errors
  </verify>
  <done>
- TranscriptPanel displays both transcript and streamingEntry
- StreamingTranscriptEntry integrated with onComplete callback
- Auto-scroll triggers on streamingEntry changes
- TypeScript compiles without errors
- Dev server runs without errors
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **TypeScript compilation:** `npm run build` succeeds
2. **Components exist:** StreamingTranscriptEntry component created and exported
3. **Store integration:** streamingEntry state and actions exist in debateStore
4. **UI wiring:** TranscriptPanel uses streamingEntry from store
5. **Dev server:** `npm run dev` runs without console errors
</verification>

<success_criteria>
- Streaming transcript entry component displays incremental text
- Debate store manages streaming state separately from completed entries
- TranscriptPanel shows both completed and streaming entries
- onComplete callback properly finalizes streaming entries to transcript
- No regression to existing UI components
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-streaming/03-02-SUMMARY.md`
</output>
